from sys import exit, argv
from os import path
from clr import AddReference
from pefile import PE, DIRECTORY_ENTRY
from abc import ABC, abstractmethod

dnlib_dll_path = path.join(path.dirname(__file__), "dnlib")
AddReference(dnlib_dll_path)

from dnlib.DotNet import ModuleDefMD, MethodDef, DummyLogger
from dnlib.DotNet.Writer import ModuleWriterOptions
from System.Reflection import Assembly, MethodInfo


class CommonHelper(ABC):

    def __init__(self, input_file_path: str) -> None:
        if not path.exists(input_file_path):
            exit("[-] File not found")

        if not path.isabs(input_file_path):
            input_file_path = path.abspath(input_file_path)

        try:
            pe = PE(input_file_path, fast_load=True)
        except:
            exit("[-] Invalid PE file")

        dotnet_dir = DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR']
        if pe.OPTIONAL_HEADER.DATA_DIRECTORY[dotnet_dir].VirtualAddress == 0:
            exit("[-] File is not .NET")

        self.input_file_path = input_file_path
        self.file_module = ModuleDefMD.Load(input_file_path)
        self.file_assembly = Assembly.LoadFile(input_file_path)

    def __save_module(self) -> None:
        options = ModuleWriterOptions(self.file_module)
        options.Logger = DummyLogger.NoThrowInstance
        split_name = self.input_file_path.rsplit(".", 1)
        pattern = "{0}_deobf" if len(split_name) == 1 else "{0}_deobf.{1}"
        cleaned_filename = pattern.format(*split_name)
        print(f"Output file: {cleaned_filename}")
        
        self.file_module.Write(cleaned_filename, options)

    def _get_filtered_methods(self) -> list[MethodDef]:
        flat_map = lambda f, xs: [y for ys in xs for y in f(ys)]

        filtered_modules = filter(lambda module_type: module_type.HasMethods, self.file_module.Types)
        filtered_methods = flat_map(lambda module: filter(lambda method: method.HasBody, module.Methods), filtered_modules)
        return filtered_methods

    @abstractmethod
    def deobfuscate_file(self, args: list) -> bool:
    	...

    def parse_input_file(self, args: list = []) -> None:
        if not self.deobfuscate_file(*args):
            print("Deobfuscation failed!")
            return

        print("Deobfuscation success, saving output file!")
        self.__save_module()