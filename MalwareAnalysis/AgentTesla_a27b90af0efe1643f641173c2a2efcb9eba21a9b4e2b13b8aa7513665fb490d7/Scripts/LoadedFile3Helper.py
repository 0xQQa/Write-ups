from sys import exit, argv
from os import path
from clr import AddReference
from struct import unpack

from CommonHelper import CommonHelper

dnlib_dll_path = path.join(path.dirname(__file__), "dnlib")
AddReference(dnlib_dll_path)
from dnlib.DotNet.Emit import OpCodes, Instruction
from System.Reflection import MethodInfo


class StringDecryptor:

    def __init__(self, static_string_arrr: bytearray) -> None:
        decrypt_string, decrypt_char, decrypt_smt = self.__decrypt_string, self.__decrypt_char, self.__decrypt_smt
        common_string_decrypt = self.__common_string_decrypt
        m_2 = lambda x: common_string_decrypt(x, 835887583,  4142697291, {0: decrypt_string, 2: decrypt_char, 3: decrypt_smt})
        m_3 = lambda x: common_string_decrypt(x, 772828559,  42226050,   {1: decrypt_string, 3: decrypt_char, 2: decrypt_smt})
        m_4 = lambda x: common_string_decrypt(x, 772689183,  1601313734, {1: decrypt_string, 3: decrypt_char, 2: decrypt_smt})
        m_5 = lambda x: common_string_decrypt(x, 3765275755, 3995412198, {2: decrypt_string, 1: decrypt_char, 3: decrypt_smt})
        m_6 = lambda x: common_string_decrypt(x, 2984458215, 1669748591, {0: decrypt_string, 1: decrypt_char, 2: decrypt_smt})
        self.m_dispatcher = (m_2, m_3, m_4, m_5, m_6)
        self.static_string_arrr = static_string_arrr

    def __decrypt_char(self, offset: int) -> str:
        return self.static_string_arrr[offset].decode()

    def __decrypt_string(self, offset: int) -> str:
        str_len = unpack("<I", self.static_string_arrr[offset: offset + 4])[0]
        return self.static_string_arrr[offset + 4: offset + 4 + str_len].decode()

    def __decrypt_smt(self, offset: int) -> Exception:
        raise Exception("Unused invoked!")

    def __common_string_decrypt(self, x: int, mul_val: int, xor_val: int, ops_dict: dict) -> str:
        x = ((x * mul_val) ^ xor_val) & 0xFFFFFFFF
        num = x >> 30
        x = (x & 1073741823) << 2

        return ops_dict[num](x) if num in ops_dict else "err!"

    def decrypt(self, method_idx: int, method_arg: int) -> str:
        return self.m_dispatcher[method_idx](method_arg)


class LoadedFile3Helper(CommonHelper):

    def __init__(self, input_file_path: str, input_file_static_strings: str) -> None:
        if not path.exists(input_file_static_strings):
            exit("[-] Static strings file not found")

        if not path.isabs(input_file_static_strings):
            input_file_static_strings = path.abspath(input_file_static_strings)

        with open(input_file_static_strings, "rb") as tmp_file:
            static_string_arrr = tmp_file.read()
            self.static_string_decryptor = StringDecryptor(static_string_arrr)

        super().__init__(input_file_path)

    def __patch_call_in_arg_place(self, method: MethodInfo, insnIdx: int, f_no: int) -> None:
        arg_call = int(method.Body.Instructions[insnIdx - 1].Operand)
        decrypted_str = self.static_string_decryptor.decrypt(f_no, arg_call)

        method.Body.Instructions[insnIdx - 1].OpCode = OpCodes.Ldstr
        method.Body.Instructions[insnIdx - 1].Operand = decrypted_str

        start_nop_offset = method.Body.Instructions[insnIdx - 1].Offset + method.Body.Instructions[insnIdx - 1].GetSize()
        replaced_insn_size = method.Body.Instructions[insnIdx].GetSize()

        for tmpInsnIdx in range(replaced_insn_size - 1):
            method.Body.Instructions.Insert(insnIdx + tmpInsnIdx, OpCodes.Nop.ToInstruction())

        for tmpInsnIdx in range(replaced_insn_size):
            method.Body.Instructions[insnIdx + tmpInsnIdx].OpCode = OpCodes.Nop 
            method.Body.Instructions[insnIdx + tmpInsnIdx].Operand = None 
            method.Body.Instructions[insnIdx + tmpInsnIdx].Offset = start_nop_offset + tmpInsnIdx

    def __force_patch_call_in_arg_place(self, method: MethodInfo) -> None:
        patched_insn = 0
        while True:
            method_repaired = True
            for insnIdx, insn in enumerate(method.Body.Instructions):
                looked_call, f_no = self.__filter_call_method(insn)
                if looked_call:
                    method_repaired = False
                    break

            if method_repaired:
                return patched_insn
                
            patched_insn += 1
            self.__patch_call_in_arg_place(method, insnIdx, f_no)

    def __filter_call_method(self, insn: Instruction) -> tuple[bool, int|None]:
        if insn.OpCode != OpCodes.Call or '<Module>::smethod_' not in str(insn.Operand):
            return False, None

        f_no = int(str(insn.Operand).split('_')[1][0]) - 2
        if f_no < 0:
            return False, None

        return True, f_no 

    def __patch_all_occurences_of_encrypted_strings(self) -> None:
        return sum(map(self.__force_patch_call_in_arg_place, self._get_filtered_methods()))

    def deobfuscate_file(self, *args: list) -> bool:
        return self.__patch_all_occurences_of_encrypted_strings() > 0
       

if __name__ == "__main__":
    if len(argv) != 3:
        exit(f"[!] Usage: {argv[0]} <dotnet_file_path> <extracted_static_strings_path>")

    loaded_file_3_helper = LoadedFile3Helper(*argv[1:])
    loaded_file_3_helper.parse_input_file()
