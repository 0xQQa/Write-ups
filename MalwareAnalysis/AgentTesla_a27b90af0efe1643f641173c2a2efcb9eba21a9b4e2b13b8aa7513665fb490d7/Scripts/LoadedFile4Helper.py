from sys import exit, argv
from clr import AddReference
from os import path
from CommonHelper import CommonHelper

dnlib_dll_path = path.join(path.dirname(__file__), "dnlib")
AddReference(dnlib_dll_path)
from dnlib.DotNet.Emit import OpCodes, Instruction
from System.Reflection import MethodInfo


class UnCFF:
	PATTERN_START, PATTERN_START_LEN = (OpCodes.Ldc_I4, OpCodes.Stloc, OpCodes.Br), 3
	COMMON_CHUNK, COMMON_CHUNK_LEN = (OpCodes.Nop, OpCodes.Ldloc, OpCodes.Ldc_I4, OpCodes.Ceq, OpCodes.Brfalse), 5
	PATTERN_BODY, PATTERN_BODY_LEN = (OpCodes.Ldc_I4, OpCodes.Stloc), 2
	PATTERN_END, PATTERN_END_LEN = (OpCodes.Br, OpCodes.Br), 2

	def __try_get_pattern(self, method: MethodInfo, max_insn: int, skip_count: int, pattern: tuple, pattern_len: int, extra_arg=lambda _:True) -> tuple[bool, int|None]:
		for idx, insn in enumerate(method.Body.Instructions, start=skip_count):
			if idx + pattern_len > max_insn:
				return False, None

			tmp_ops = tuple(map(lambda x: method.Body.Instructions[idx + x].OpCode, range(pattern_len)))
			if tmp_ops == pattern and extra_arg(idx):
				return True, idx

		return False, None

	def __try_found_start(self, method: MethodInfo, max_insn: int) -> tuple[bool, int|None, str|None]:
		found_pattern, idx = self.__try_get_pattern(method, max_insn, 0, self.PATTERN_START, self.PATTERN_START_LEN)
		if found_pattern:
			dispatcher_variable = method.Body.Instructions[idx + 1].Operand
			return True, idx, dispatcher_variable

		return False, None, None

	def __try_get_rest(self, method: MethodInfo, max_insn: int, skip_count: int, dispatcher_variable: str) -> list|None:
		skip_count += self.PATTERN_START_LEN
		chunks = {}
		found_end_pattern = False
		points_to_dispatcher = lambda idx: method.Body.Instructions[idx + 1].Operand == dispatcher_variable
		copy_instructions = lambda start_idx, end_idx: tuple(map(lambda idx: method.Body.Instructions[idx], range(start_idx, end_idx)))
		flat_map = lambda f, xs: [y for ys in xs for y in f(ys)]

		while skip_count < max_insn:
			found_pattern, idx = self.__try_get_pattern(method, max_insn, skip_count, self.COMMON_CHUNK, self.COMMON_CHUNK_LEN, points_to_dispatcher)
			if not found_pattern:
				continue

			skip_count = idx + self.COMMON_CHUNK_LEN
			chunk_no = method.Body.Instructions[idx + 2].Operand
			found_pattern, idx = self.__try_get_pattern(method, max_insn, skip_count, self.PATTERN_BODY, self.PATTERN_BODY_LEN, points_to_dispatcher)
			if not found_pattern:
				found_end_pattern, idx = self.__try_get_pattern(method, max_insn, skip_count, self.PATTERN_END, self.PATTERN_END_LEN)
				idx += self.PATTERN_END_LEN
				break

			founed_chunk = copy_instructions(skip_count, idx)
			skip_count = idx + self.PATTERN_BODY_LEN
			chunks |= {chunk_no: founed_chunk}

		if not found_end_pattern:
			return None

		tail = {len(chunks): copy_instructions(idx, max_insn)}
		chunks |= tail
		chunks = flat_map(lambda x: x, dict(sorted(chunks.items())).values())
		return chunks

	def __tokenize(self, method: MethodInfo) -> list|None:
		max_insn = len(method.Body.Instructions)
		
		found_start, start_idx, dispatcher_variable = self.__try_found_start(method, max_insn)
		if not found_start:
			print(f"[-] UnCFF didn't found obfuscation for {method.Name}")
			return None

		body = self.__try_get_rest(method, max_insn, start_idx, dispatcher_variable)
		if not body:
			print(f"[-] UnCFF fail for {method.Name}")
			return None

		if start_idx > 0:
			head = list(map(lambda x: method.Body.Instructions[x], range(start_idx)))
			body = head + body

		new_insn_len = len(body)
		if new_insn_len < max_insn:
			body = body + list(map(lambda x: OpCodes.Nop.ToInstruction(), range(max_insn - new_insn_len)))

		return body

	def update_method(self, method: MethodInfo) -> int:
		instructions = self.__tokenize(method)
		max_insn = len(method.Body.Instructions)

		if not instructions or len(instructions) == 0:
			return 0

		offset = 0
		for idx, insn in enumerate(instructions):
			method.Body.Instructions[idx] = instructions[idx]
			method.Body.Instructions[idx].Offset = offset
			offset += method.Body.Instructions[idx].GetSize()

		return len(instructions)


class LoadedFile4Helper(CommonHelper):

	def __repair_control_flow(self) -> None:
		un_cff = UnCFF()
		return sum(map(un_cff.update_method, self._get_filtered_methods()))

	def deobfuscate_file(self, *args: list) -> bool:
		return self.__repair_control_flow() > 0


if __name__ == "__main__":
    if len(argv) != 2:
        exit(f"[!] Usage: {argv[0]} <dotnet_file_path>")

    loaded_file_4_helper = LoadedFile4Helper(*argv[1:])
    loaded_file_4_helper.parse_input_file()

