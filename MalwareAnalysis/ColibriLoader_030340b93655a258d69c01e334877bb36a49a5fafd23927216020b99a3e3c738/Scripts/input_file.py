import idc
import idautils
import ida_idp

def find_calls_to_patch(target_functions):
    flat_map = lambda f, xs: [y for ys in xs for y in f(ys)]
    
    filtered_functions = filter(lambda x: idc.get_name(x) not in target_functions, idautils.Functions())
    functions_addr = flat_map(Chunks, filtered_functions)
    heads = flat_map(lambda x: Heads(*x), functions_addr)
    get_valid_calls = lambda x: ida_idp.is_call_insn(x) and idc.get_operand_value(x, 0) in target_functions
    calls = filter(get_valid_calls, heads)
    return calls

def patch_calls(target_addresses):
    call_and_add_size = 0x5 + 0x3
    for patch_addr in target_addresses:
        patch_addr = prev_head(patch_addr)
        prev_insn_size = idautils.DecodeInstruction(patch_addr).size
      
        patch_size = call_and_add_size + prev_insn_size
        nops = b"\x90" * patch_size
        ida_bytes.patch_bytes(patch_addr, nops)
        print(f"Patching at {patch_addr} ...done")

    print(f"Fixed all redundant functions")


if __name__ == "__main__":
    targets_ea = (idc.get_name_ea_simple("sub_42DF00"), idc.get_name_ea_simple("sub_42C820"))
    taregt_calls = find_calls_to_patch(targets_ea)
    patch_calls(taregt_calls)

#https://github.com/ihack4falafel/ROR13HashGenerator/blob/master/pre_computed_hashes/kernel32.md